Heroku Rust CLI — Architecture Guide (for Agents)

Purpose
- Schema-driven CLI and TUI for Heroku, implemented in Rust.
- Everything derives from the embedded Heroku JSON Hyper-Schema; no hand-maintained command tables.
- This document captures design/decisions so an agent (e.g., Codex) can safely extend the project.

Repository Layout
- heroku/Cargo.toml: Workspace root and shared deps.
- crates/
  - registry: Loads embedded Hyper-Schema, derives command registry, and builds a dynamic Clap tree.
  - cli: Non-interactive CLI path; routes to TUI when no subcommand.
  - tui: Ratatui-based terminal UI split into app (state), ui (render), preview (helpers), theme (colors/styles).
  - api: Minimal HTTP client (reqwest) with auth precedence.
  - util: Utilities (redaction, helpers).
  - engine: Placeholder workflow engine.
  - xtask: Dev helper for inspecting schema→registry outputs (not used by runtime).
- heroku-schema.json: Embedded as include_str! and used as the single source of truth.
- plans/: Architecture and execution plans. See plans/plan.txt and this file.

Dynamic Registry (Schema → Commands/Args/Flags)
- Location: crates/registry/src/lib.rs
- Input: The root Hyper-Schema JSON (include_str!("../../../../heroku-schema.json")).
- Discovery:
  - Walk all objects containing links[]
  - For each link: extract href, method, description/title, and schema (if present).
- Command naming (avoid collisions and reflect scope):
  - Derive name from concrete (non-placeholder) path segments plus action (inferred from method/href):
    - group = first concrete segment (e.g., apps, users).
    - subcommand = remaining concrete segments joined with ":" and then ":<action>".
    - Examples:
      - GET /apps → apps:list
      - GET /users/{account}/apps → users:apps:list
      - GET /apps/{app}/releases → apps:releases:list
  - Action inference:
    - GET with a trailing placeholder → info
    - GET with trailing concrete collection → list
    - POST → create; PATCH → update; DELETE → delete
- Positional arguments (from href placeholders):
  - Name: inferred from the previous concrete path segment, singularized, e.g., /apps/{…} → <app>.
  - Description: decode the placeholder JSON Pointer (e.g., {(%23%2Fdefinitions%2Fapp%2Fdefinitions%2Fidentity)})
    - Resolve to a node in the schema:
      - If node has description → use it.
      - Else if node has anyOf → resolve each ref/branch and join their descriptions with " *or* ".
      - Else fallback: "Path parameter derived from the endpoint URL."
  - Stored in CommandSpec.positional_args and CommandSpec.positional_help (name→desc).
- Flags (from link.schema.properties):
  - Required flags from link.schema.required array.
  - Resolve $ref when present; merge missing fields from referenced definition (type, description, enum, default).
  - Types: boolean becomes presence flag; others treated as string values (CLI-level; type used for help only).
  - Enums: capture enum values; used to validate in Clap and to cycle/select in the TUI.
  - Defaults: capture scalar defaults; enum without default defaults to first option.
  - Stored in CommandFlag { name, required, type, enum_values, default_value, description }.

Clap Tree (Non-Interactive CLI)
- Build from the derived Registry:
  - Root command has global flags (e.g., --json, --verbose placeholder).
  - Group commands: one subcommand per group (first path segment).
  - Subcommand per derived command with positional args and flags.
- Enum validation uses PossibleValuesParser; strings leaked into 'static for Clap’s builder lifetime (acceptable in a short-lived CLI process).

HTTP Client
- Location: crates/api/src/lib.rs
- Reqwest client with:
  - Base URL default: https://api.heroku.com
  - Headers: Accept v3, User-Agent
  - Timeout: 30 seconds
  - Auth precedence: HEROKU_API_KEY env > ~/.netrc (basic parser)
- Redaction: implemented in crates/util (Authorization and secret-like values masked in outputs).

TUI Architecture (Ratatui)
- MVU/Flux-Inspired:
  - Single state: App (the store).
  - Messages: app::Msg enumerates all high-level intents (focus nav, search edit, list nav, input edit, toggles, run, copy, help).
  - Update: app::update(&mut App, Msg) mutates state; returns Option<Effect> for side effects (e.g., clipboard copy).
  - View: ui.rs renders purely from &App; no state mutation in rendering.
  - Controller: lib.rs translates key events into Msg, calls update, then handles any effects (copy to clipboard, etc.).
- Layout:
  - Top: Search panel with cursor; shows a [DEBUG] badge when DEBUG enabled.
  - Middle: three panes
    - Commands (left): stateful List with auto-scroll; displays Clap-compatible "<group> <subcommand>"; dimmed selection.
    - Inputs (middle): required positionals first, then flags; current item highlighted; cursor indicates typing position.
      - Footer pinned: "Tab focus  Enter run  Ctrl+H help  Ctrl+C quit".
    - Command (right): shows constructed CLI command; header includes [Ctrl+Y] Copy.
  - Bottom: Logs panel (app.logs).
- Keybindings:
  - Quit: Ctrl+C
  - Help (modal): Ctrl+H (title includes [Esc] Close); Esc closes modals globally.
  - Copy current command: Ctrl+Y
  - Focus: Tab/Shift-Tab cycles Search → Commands → Inputs.
  - Search: type to filter; Backspace deletes; Esc clears.
  - Commands: Up/Down select; Enter focuses Inputs (Inputs sync live on selection change).
  - Inputs: Up/Down field nav; Left/Right cycles enum values; Space toggles boolean flags; Enter runs.
- Help Modal (Heroku CLI style):
  - Sections: Usage, Description, Arguments (inline name: description), Options (inline flags with type/required/enum/default — description), Example.
  - Footer pinned: "Hint: Ctrl+H close  Ctrl+Y copy".
  - Positional and flag descriptions derived from schema, including anyOf resolution with "*or*".

Theming
- Subtle dark theme with Cloud Blue accents:
  - ACCENT: #00A3E0 (Heroku Cloud Blue); ACCENT_DIM: #0088BB.
  - BG_HIGHLIGHT / BG_SELECT: blue-tinted dark shades.
  - Focused borders use ACCENT; list selection uses muted foreground + BG_SELECT (dim).

Workflows Architecture (Engine + CLI/TUI)
- Status: Engine scaffolded; execution not yet implemented.
- Data model (crates/engine):
  - WorkflowFile { workflows: HashMap<String, Workflow> }
  - Workflow { tasks: Vec<Task> }
  - Task { name: String, command: String, with: serde_json::Value, if: Option<String> }
  - ContextState { env: HashMap<String, String>, tasks: HashMap<String, TaskResult> }
  - TaskResult { status: String, output: Value, logs: Vec<String> }
- Loader:
  - load_workflow_from_file(path): reads YAML/JSON into a WorkflowFile; workflows keyed by name.
- Interpolation & conditions:
  - interpolate_value recursively resolves ${{ ... }} in strings/objects/arrays using ContextState.
  - resolve_expr supports:
    - env.VAR
    - tasks.<name>.output.<path>
    - Simple equality in if expressions (a == "b") ⇒ "1"/"0" for truthiness.
- CLI integration (crates/cli):
  - Feature flag gated: set FEATURE_WORKFLOWS=1 to enable.
  - Subcommands: workflow list | preview [--file <path>] [--name <name>] | run [--file] [--name].
- TUI integration (planned):
  - Add a Workflows pane listing files from workflows/ and workflows in a file.

Security & Guardrails
- Never log tokens/secrets; redact Authorization and secret-looking values.

Important Decisions & Rationale
- Dynamic derivation over static tables: keeps CLI/TUI in sync with schema; zero manual drift.
- Unique command naming: prevents collisions across scoped endpoints (e.g., users:apps:list vs apps:list) and preserves all functionality.
- Clap 'static leaks: acceptable trade-off for a CLI; simplifies dynamic parser construction.
- MVU/Flux-style state management: predictable updates, easier testing, and cleaner separation of concerns.
- Pinned footers (Inputs/Help): hint text stays stable regardless of content length.

Extending the System (Agent Tips)
- Add new features via Msg + update:
  - Define a new app::Msg for the intent; implement in app::update; render in ui.rs.
  - Keep side effects in Effects; apply in lib.rs after calling update.
- Registry enhancements:
  - Support query parameters in links (map to flags with type/description from schema).
  - Expand placeholder resolution to support oneOf/allOf combos similarly to anyOf.
  - Add unit tests for representative endpoints (apps, releases, config, dynos) to lock derivation.
- API client improvements:
  - Retries/backoff (429/5xx), structured errors, robust netrc parsing.
- TUI polish:
  - Dedicated widgets for booleans/enums if needed; scrollable content panes; breadcrumbs or path indicator.
  - Optional debug badge and diagnostics panel.

Getting Started (Dev)
- Build: `cd heroku && cargo build --workspace`
- TUI: `cargo run -p heroku-cli`
- Live API: `export HEROKU_API_KEY=...`.
- Enable debug-only features: `export DEBUG=1`.

Testing Strategy
- Goals: Prevent regressions in schema derivation, ensure CLI shape and help are stable, validate MVU update logic, and verify security guardrails (redaction, auth precedence).

- Registry (crates/registry)
  - Unit: given small, in-repo schema fragments, assert that:
    - Command names are derived correctly (group/sub + action).
    - Positional args are named and singularized correctly.
    - Positional descriptions resolve directly and via anyOf (joined with "*or*").
    - Flags resolve $ref (type/description/enum/default) and required from `required`.
  - Golden: snapshot a subset of derived CommandSpec for representative endpoints (apps, releases, config, dynos). Keep snapshots small and stable.

- CLI (crates/cli)
  - Build Clap and snapshot `--help` for a couple of commands to catch naming/flag drift.

- API (crates/api)
  - Unit: auth precedence (HEROKU_API_KEY over ~/.netrc) with temporary files; redaction on Authorization header.
  - Future: retry/backoff behavior with a mocked client.

- TUI (crates/tui)
  - Update loop: feed Msg sequences to `app::update` and assert state transitions (focus, selection, field edits, toggles).
  - Rendering (optional): use ratatui-testing or golden rendering for key views (search, commands, inputs, help modal) with a small, deterministic registry stub.
  - Keybindings: map key → Msg tests to preserve ergonomics (Ctrl+H/C/Y, Tab/Shift-Tab, arrows).

- Security
  - Redaction: snapshot tests for util::redact_sensitive covering Authorization and secret-like patterns.
  - Logging: ensure help/command previews never include tokens;

- Test Data
  - Keep minimal JSON schema fragments under a `tests/data/` folder inside the registry crate for unit tests.
  - Avoid reliance on the full heroku-schema.json in unit tests; use focused fixtures to keep tests fast and readable.
